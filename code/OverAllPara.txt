// All Parameters;
0	// unsigned int seed; random seed (10 integer characters);
./	// char *root_direct; root directory; use "\\" to indicate "\", including the last "\"; ".\" subdirectory; ".\" used in Windows, "./" used in Linux;
0	// int numRun; number of running under same condition;
1e-5	// double p_dEPLSILON; running precision;
// Parameters for CNet;
-1	// int p_nNetTyp; network type; -1, default value (self-grow); 0, Random graph network; 1, Scale-free network; 2, Small world network; 3, Local world network; 4, Exponential network; 5, Cooper-Frieze network; 6, Directed scale-free network; 7, Multi-Local-World (MLW);
-1	// int p_nBasicTyp; basic network type: -1, default value; 0, globally paired network; 1, star network; 2, neighbor network; 3, lace network; 4, lattice; 5, wheel; 6, regular random graph; 7, directional hierarchy network; 8, random graph;
0	// int p_nDirected; directed or not; -1, default value; 0, undirected; 1, directed;
1.0	// double p_dConWeiUp; connection weight's upper bound;
0.01	// double p_dConWeiLow; connection weight's lower bound;
1.0	// double p_dAdjWei; adjustment of connection weight;
0.5	// double p_dConWeiThres; connection weight's threshold;
// for basic network;
1	// int p_nEdgePerNode; p_nNumAgent/10.0, No. of edges for each new node; in local world network, p_nEdgePerNode<=p_nLocalView;
3	// int p_nLaceR; in lace network;
1	// int p_nLattice; in lattice network, each agent connects his nearest and next nearest neighbors; node i connect to node i-(int)(p_nLattice/2.0) to i+(int)(p_nLattice/2.0); 
2.0	// double p_dAvgDegree; in random network, it is 2*p_nEdgePerNode; in Scale-free, local world, exponential network, it is (2*p_nEdgePerNode*(p_nNumAgent-N0)+2*E0)/p_nNumAgent; N0, initial nodes; E0, already set connections among N0 nodes; 
// for Scale-free, Small world, Local world network;
1	// int p_nLocalView; local view of each new agent; in exponential network, p_nLocalView==p_nEdgePerNode;
0.5	// double p_dReWire; prob to rewire one connection;
1.0	// double p_dAddWireProb; prob of adding new edges in building up Small Word network;
0.1	// double p_dRandomProb; random network, prob for adding an edge;
// for Copper-Frieze network;
4	// int p_nNumAddEdge; No. of edges that one time step can add at most, uniformly distributed; 
0.5	// double p_dAlfaCF; prob of OLD process for generating new edge; 1-p_dAlfa, probability of NEW process for adding new vertex;
0.8	// double p_dBetaCF; In NEW process, prob that choices of terminal vertices are made uniformly; 1-p_dBeta, prob that choices of terminal vertices are made according to degree;
0.8	// double p_dGamaCF; In OLD process, prob that choices of terminal vertices are made uniformly; 1-p_dGama, prob that choices of terminal vertices are made according to degree;
0.8	// double p_dSetaCF; In OLD process, prob that the initial node is selected uniformly; 1-p_dSeta, prob that the initial node is selected according to degree;
// for Directed scale-free network; 3 actions; 
-1	// int p_nDegMode; for directed network, -1, record all degrees; 0, record out-degrees; 1, record in-degrees;
1.0	// double p_dSetaIN; in-degree constant;
1.0	// double p_dSetaOUT; out-degree constant;
0.3	// double p_dAlfaDS; prob that add a new vertex v together with an edge from v to an existing vertex w, where w is chosen according to din+p_dSetaIn;
0.6	// double p_dBetaDS; p_dAlfaDS+0.3, prob that add an edge from an existing vertex v to an existing vertex w, where v and w are chosen independently, v according to dout+p_dSetaOUT and w according to din+p_dSetaIN;
1.0	// double p_dGamaDS; prob that add a new vertex w and an edge from an existing vertex v to w, where v is chosen according to dout+p_dSetaOUT;
// for Multi-Local-World (MLW); 3 actions; p_dP+p_dQ+p_dR=1.0
0.5	// double p_dAlfaMLW; constant to decide pow(T(i), p_dAlfaMLW); the newly created local world has more attractivity;
2	// int p_nM1; No. of new edges added in action 1;
2	// int p_nM2; No. of new edges added in action 2;
2	// int p_nM3; No. of new edges added in action 3;
0.3	// double p_dP; prob that a new local-world with 1 node is created. Its p_nM1 links to the existing local-worlds, decided by the prob of the existing local-worlds decided by their connctions; repeat p_nM1 times;
0.3	// double p_dQ; prob that a new node is added to an existing local-world, which has p_nM2 links with the nodes within the same local-world. The prob that local-world i is selected is proportional to pow(T(i), p_nAlfaMLW); repeat p_nM2 times;
0.4	// double p_dR; prob that a total of p_nM3 links are added to the network: first, a local-world and a node in this local-world are randomly selected; another node is randomly selected for each link with the prob decided by its degrees; repeat p_nM3 times; 
// Parameters for CPara;
2	// int p_nCode; 2: using binary code to encode semantic item and semantic roles;
4	// int p_nNumSemRole; 4 types of semantic parts; Agent, Predicate1, Predicate2, Patient;
4	// int p_nNumSemAgent;
4	// int p_nNumSemPred1;
4	// int p_nNumSemPred2;
4	// int p_nNumSemPat;
3	// int p_nLengthWord; the length of utterance unit;
1	// int p_nAgSamePat;
// Parameters for CSemSpace;
0	// int p_nSemDist; 0, uniform dist; 1, identical Gaussian; 2, different Gausian; 3, identical Power law; 4, reverse identical Power law; 5, identical random; 6, different random;
3.0	// double p_dRatioSV_SVO; default: 1.0;
0.5	// double p_dGausAvg;
0.1	// double p_dGausVar;
1.0	// double p_dPowerLawA;
-1.0	// double p_dPowerLawK;
// Parameters for CCue;
1	// int p_nAtLeastOneCue; 1, at least one cue; 0, zero cue is possible;
1	// int p_nMaxCueNum; maximum cue number;
0	// int p_nWrongCueTyp; -1, default; 0, wrong cue is randomly selected; 1, wrong cue has no component to be identical to the correct meaning;
0.75	// double p_dDefCueStr; 0.75: 0.5+0.5*0.5 default cue's strength;
0.4	// double p_dCueReliab; cue's relaibility;
0.01	// double p_dCueReliabVar; cue's reliability's variance;
// Parameters for CMeanUtter;
30	// int p_nNumUtterSyl; total number of syllables;	 
// Parameters for CBuffer;
1	// int p_nBufTyp; 0, no record instance; 1, record instance; 2, record instance, when deleting, according to instance;
0	// int p_nRemBuf; 0, no removal of fully decomposible M-U mappings; 1, removal of fully decomposible M-U mappings;
0	// int p_nVarBufSize; 0, all agents have same buffer sizes; 1, agents have heterogeneous buffer sizes;
40	// int p_nMaxBufSize;
0	// int p_nMaxBufSizeVar;
// Parameters for CLexRule;
1.0	// double p_dInitBasicRuleStr;
0.5	// double p_dInitLexRuleStr;
0.1	// double p_dAdjLexRuleStrInc;
0.1	// double p_dAdjLexRuleStrDec;
1.0	// double p_dLexRuleStrUp;
0.01	// double p_dLexRuleStrLow;
1.0	// double p_dInitBasicAssoWei;
0.5	// double p_dInitAssoWei;
0.1	// double p_dAdjAssoWeiInc;
0.1	// double p_dAdjAssoWeiDec;
1.0	// double p_dAssoWeiUp;
0.01	// double p_dAssoWeiLow;
6	// int p_nMaxCatNum;
0.05	// double p_dForgetRateLexRule;
0.05	// double p_dForgetRateAssoWei;
// Parameters for CCat;
60	// int p_nMaxLexNum;
20	// int p_nMaxSynNum;
// Parameters for CSynRule;
1.0	// double p_dInitBasicSynRuleStr;
0.5	// double p_dInitSynRuleStr;
0.1	// double p_dAdjSynRuleStrInc;
0.1	// double p_dAdjSynRuleStrDec;
1.0	// double p_dSynRuleStrUp;
0.01	// double p_dSynRuleStrLow;
0.05	// double p_dForgetRateSynRule;
2	// int p_nMaxNumCatRelated; 2: maximum number of catgeory one syntactic rule is related;
2	// int p_nNumOrderTyp1; SV, VS orders for "Predicate<Agent>" meanings;
6	// int p_nNumOrderTyp2; SVO, SOV, OSV, VSO, VOS, OVS orders for "Predicate<Agent, Patient>" meanings;
// Parameters for CIMMem;
0	// int p_nChosWin; 0, winner takes all; 1, probability; 2, random adjust and winner takes all;
0.05	// double p_dAdjCombOptionStr; when p_nChosWin=2, adjustment of each CombOption;
0.5	// double p_dNeuLexStr;
0.5	// double p_dNeuAssoWei;
0.5	// double p_dNeuSynStr;
3	// int p_nMaxNumLexRules;
3	// int p_nMaxNumCats;
3	// int p_nMaxNumSynRules;
0	// int p_nVarIMMem; 0, all agents have same IMMem sizes; 1, agents can have heterogeneous IMMem sizes;
40	// int p_nMaxNumCombOption;
0	// int p_nMaxNumCombOptionVar;
// Parameters for CLTMem;
1	// int p_nProComp2_3; -1, default value; 0, in production, select syntactic rules based on combined strength; 1, in production, select syntactic rules based on whether 2 syntactic rules can get unique global order;
0	// int p_nPerComp2_3; -1, default value; 0, in perception, select syntactic rules based on combined strength; 1, in perception, select syntactic rules based on whether 2 syntactic rules can get unique global order;
1	// int p_nChoIdentical; -1, default value; 0, not allow to choose repeated chosen syntactic rules; 1, allow to choose repeated chosen syntactic rules;  
1	// int p_nVarLTMem; 0, all agents have same LTMem sizes; 1, agents can have heterogeneous LTMem sizes;
20	// int p_nMaxLexRule;
5	// int p_nMaxLexRuleVar;
20	// int p_nMaxCat;
0	// int p_nMaxCatVar;
20	// int p_nMaxSynRule;
0	// int p_nMaxSynRuleVar;
100	// int p_nMaxRecPat;
0	// int p_nDecHolistPhrase; initial value: -1; 0, according to category and syntactic rules; 1, random combine;
// Parameters for CAgent;
1.0	// double p_dChildAdultAbiRatio; children and adult's learnability and creativity's ratio;
0	// int p_nVarCrtDec; 0, all agents have same creation and detection rates; 1, agents can have heterogeneous creation and detection rates;
1	// int p_nOnlyHolist; 0, allow agents to create compositional rules; 1, allow agents only create holistic rules;
0.25	// double p_dRandCrtRateWord;
0.0	// double p_dRandCrtRateWordVar;
0.25	// double p_dRandCrtRatePhrase;
0.0	// double p_dRandCrtRatePhraseVar;
0.25	// double p_dRandCrtRateHolist;
0.0	// double p_dRandCrtRateHolistVar;
0.25	// double p_dDetRecPatRate;
0.0	// double p_dDetRecPatRateVar;
2	// int p_nNoDetRecPatExm; 2, default value; number of M-U mappings which share the recurrent pattern to allow detecting this recurrent pattern;
2	// int p_nNoAcqCatSynExm; 2, default value; number of M-U mappings which share same use of lexical rules to allow building categories and syntactic rules; 
0.25	// double p_dDetLocOrdRate;
0.0	// double p_dDetLocOrdRateVar;
0	// int p_nFeedbackTyp; 0, hardfeedback; 1, softfeedback;
50.0	// double p_dSlope;
0.75	// double p_dHardFeedback; 0.5+0.5*0.5 hard feedback;
2	// int p_nHandleFailedTyp; 0, in Suc, incr winning, decr losing; in Fail, decr winning, incr losing; 1, only handle winning; 2, in Suc, incr winning, decr losing; in Fail, decr winning;
0	// int p_nAvoidLexFlag; 0, no avoid Synonym/Homonym; 1, avoid Synonym/Homonym;
0	// int p_nAvoidSynFlag; 0, no avoid SynRule; 1, avoid SynRule;
0	// int p_nHandleBuf; initial value: -1; 0, acqlexcat after each communication; 1, acqlexcat when the buffer is full;
0	// int p_nAdjModel; -1, default value; 0, linear; 1, nonlinear;
0	// int p_nTakePersp; -1, default; 0, no take; 1, take specific; 2, random take;
-1	// int p_nPerspective; -1, default; 0, agent-perspective; 1, patient-perspective;
1	// int p_nForget; 0, no forgetting; 1, forgetting;
0	// int p_nPredCase; 0, merge Pred1 and Pred2; 1, do not merge Pred1 and Pred2;
// Parameters for CSystem;
10	// int p_nNumAgent;
200	// int p_nCheckFre; number of total sample points;
0	// int p_nDecFlag; 0, no decompose holist/phrase; 1, decompose holist/phrase;
0	// int p_nSelfTalkFlag; 0, no self-talk; 1, self-talk;
1	// int p_nRecLocOrdNo_Str; -1, default value; whether record local order's number used (0) or strength (1);
8	// int p_nComMode; 0, randomcom; 1, paircom; 2, teach-learn; 3, popagent; 4, 2D world; 5, SolCom; 6, GA RandCom; 7, MemLang RandCom; 8, Lang-JA&LTM coevolution;
1	// int p_nNumGroup; 1, one group; 2, two groups;
0	// int p_nG1HolComp; 0, holistic; 1, compo, local orders by p_nG1order; 2, compo, local orders by p_nG1SV/p_nG1VS/p_nG1VO/p_nG1OV/p_nG1SO/p_nG1OS; 
-1	// int p_nG1CompTyp; -1, default value; 0, random create compositional rules' utterance, allow homonyms; 1, do not allow homonyms; 2, use identical meaning as utterance syllable; 
-1	// int p_nG1InitCompCat; -1, default value; 0, predicate category covers all predicates; 1, there are 2 predicate categories;
0	// int p_nG1order1; if((p_nG1HolComp==1)&&(p_nG1InitCompCat==1)) group1's "Pred<Ag>" meanings local order; 0, default value; 1, SV; 2, VS;
0	// int p_nG1order2; if((p_nG1HolComp==1)&&(p_nG1InitCompCat==0/1)) group1's "Pred<Ag, Pat>" meanings local order; 0, default value; 1, SVO; 2, SOV; 3, OSV; 4, VSO; 5, VOS; 6, OVS;
0	// int p_nG1SV1; if((p_nG1HolComp==2)&&(p_nG1InitCompCat==1)) 0, no SV local order; 1, SV local order for "Pred<Ag>" meanings;
0	// int p_nG1VS1; if((p_nG1HolComp==2)&&(p_nG1InitCompCat==1)) 0, no VS local order; 1, VS local order for "Pred<Ag>" meanings;
0	// int p_nG1SV; 0, no SV local order; 1, SV local order; 
0	// int p_nG1VS; 0, no VS local order; 1, VS local order; 
0	// int p_nG1VO; 0, no VO local order; 1, VO local order; 
0	// int p_nG1OV; 0, no OV local order; 1, OV local order; 
0	// int p_nG1SO; 0, no SO local order; 1, SO local order; 
0	// int p_nG1OS; 0, no OS local order; 1, OS local order; 
0.0	// double p_dG1LexNhomrate;
0.0	// double p_dG1LexVhomrate;
0.0	// double p_dG1LexNVhomrate; 
-1	// int p_nG2HolComp; -1, default value; 0, holistic; 1, compo, local orders by p_nG2order; 2, compo, local orders by p_nG2SV/p_nG2VS/p_nG2VO/p_nG2OV/p_nG2SO/p_nG2OS; 
-1	// int p_nG2CompTyp; -1, default value; 0, random create compositional rules' utterance, allow homonyms; 1, do not allow homonyms; 2, use identical meaning as utterance syllable; 
-1	// int p_nG2InitCompCat; -1, default value; 0, predicate category covers all predicates; 1, there are 2 predicate categories;
0	// int p_nG2order1; if((p_nG2HolComp==1)&&(p_nG2InitCompCat==1)) group2's "Pred<Ag>" meanings local order; 0, default value; 1, SV; 2, VS;
0	// int p_nG2order2; if((p_nG2HolComp==1)&&(p_nG2InitCompCat==0/1)) group2's "Pred<Ag, Pat>" meanings local order; 0, default value; 1, SVO; 2, SOV; 3, OSV; 4, VSO; 5, VOS; 6, OVS;
0	// int p_nG2SV1; if((p_nG2HolComp==2)&&(p_nG2InitCompCat==1)) 0, no SV local order; 1, SV local order for "Pred<Ag>" meanings;
0	// int p_nG2VS1; if((p_nG2HolComp==2)&&(p_nG2InitCompCat==1)) 0, no VS local order; 1, VS local order for "Pred<Ag>" meanings;
0	// int p_nG2SV; 0, no SV local order; 1, SV local order; 
0	// int p_nG2VS; 0, no VS local order; 1, VS local order; 
0	// int p_nG2VO; 0, no VO local order; 1, VO local order; 
0	// int p_nG2OV; 0, no OV local order; 1, OV local order; 
0	// int p_nG2SO; 0, no SO local order; 1, SO local order; 
0	// int p_nG2OS; 0, no OS local order; 1, OS local order;
0.0	// double p_dG2LexNhomrate;
0.0	// double p_dG2LexVhomrate;
0.0	// double p_dG2LexNVhomrate;
0.0	// double p_dLexSim; for 2 groups, lexical rules similarity, for syntactic rules, use G1order and G2 order to adjust;
2	// int p_nHorObliMix; 0, horizontal only; 1, oblique only; 2, horizontal and oblique;
0	// int p_nMixHorVer; 0, no mix of horizontal and vertical transmissions; 1, mix horizontal and vertical transmissions;
// when p_nHorObliMix=1 or p_nHorObliMix=2;
5	// int p_nNumAgentRep; number of agents replaced every generation;
0	// int p_nCalTransMethod; -1, default value; 0, calculate using p_dAdultChildRatio, p_dChildChildRation, p_dChildAdultRatio, and p_dVerProb; 1, calculate using p_dPCRatio, p_dACRatio, p_dCCRatio, and p_dCARatio; 2, calculate using p_dGrandChildRatio, p_dParentChildRatio, and p_dChildChildRatio;
1.0	// double p_dAdultChildRatio; probability for adult-child communication;
0.0	// double p_dChildChildRatio; probability for child-child communication;
0.0	// double p_dChildAdultRatio; probability for child-adult communication; p_dAdultChildRatio+p_dChildChildRatio+p_dChildAdultRatio=1.0;
0.1	// double p_dVerProb; probability for bio-parent teaches new agent; 1.0/p_nNumAgent, all agents have equal chances;
0.0	// double p_dPCRatio; probability for bioparent-child communication;
0.0	// double p_dACRatio; probability for nonbioparent-child communication;
0.0	// double p_dCCRatio; probability for child-child communication;
0.0	// double p_dCARatio; probability for child-adult communication; p_dPCRatio+p_dACRatio+p_dCCRatio+p_dCARatio=1.0;
0.0	// double p_dGrandCRatio; probability for grandparent-child communication;
0.0	// double p_dParentCRatio; probability for parent-child communication;
0.0	// double p_dChildCRatio; probability for child-child communication; p_dGrandCRatio+p_dParentCRatio+p_dChildCRatio=1.0;
0	// int p_nGrandCType; 0, grandparents only talk to direct grandoffspring; 1, grandparents talk to any grandchildren;
0	// int p_nParentCType; 0, parents only talk to direct offspring; 1, parents talk to any children;
0	// int p_nVerTranRandCrt; in vertical transmission, allow speaker to random create; -1, default;
1	// int p_nVerTranWrongCue; in vertical transmission, allow listener to select wrong cue; -1, default;
0	// int p_nDifAdultChild; 0, no difference; 1, child and adult have different level of linguistic abilities;
1.0	// double p_dDifRatio; 1.0, no difference; the ratio between adult's ability and children's ability;
0	// int p_nSpUpd; 0, in oblique or vertical transmissions, speakers do not update their languages; 1, speakers occasionally update their languages;
0.0	// double p_dSpUpdProb; in oblique or vertical transmissions, the probability for speakers update their languages;
5000	// int p_nNumGen;
200	// int p_nNumLearn;
// when p_nComMode=3, pop agent;
0	// int p_nHumanChimp; 0, human society; 1, chimpanzee society with linear popularity; 2, chimpanzee society with scale popularity; 3, chimpanzee society with Power-law distribution; 4, speaker and listener have different Power-law distributions; 5, normal distribution with same mean and std of power-law distribution;
1.0	// double p_dA1; p_dA1*pow(x, p_dK1);
-0.0	// double p_dK1; p_dA1*pow(x, p_dK1);
1.0	// double p_dA2; p_dA2*pow(x, p_dK2);
-0.0	// double p_dK2; p_dA2*pow(x, p_dK2);
0.0	// double p_dScale; for p_nHumanChimp=2, the scale for popularity;
0.0	// double p_dPopRat; for 1 group, popular rate;
0.0	// double p_dIntraRat; for 2 groups, intra rate;
0.0	// double p_dInterRat; for 2 groups, inter rate;
// when p_nComMode=4, 2D world;
0	// int p_nWorldX;
0	// int p_nWorldY;
0	// int p_nBlockDist; the distance within which agents can communicate with each other;
0.0	// double p_dSucRat; the percentage of "successful" infochange that can bind agents together;
-1	// int p_nSucCri; 0, default value; 0, using feedback to chek success of communication; 1, using meaning to check success of communication;
0	// int p_nMoveStep; moving step; 0, default value;
-1	// int p_n1toMCom; -1, default value; 0, normal one to one com; 1, one to many com;
// when p_nComMode=5, SolCom;
0	// int p_nSelfGrow; 0, default network; 1, self-grow network based on degree; 2, self-grow network based on UR;
// when p_nComMode=6, GA RandCom;
1	// int p_nGATimeScale; after how many communications let GA to adjust individual learning abilities;
5	// int p_nNumSp; number of speakers for children to learn from;
0	// int p_nCulSelType; cultural selection type; 0, randomly select 50% agents; 1, select best 50% agents; 
0	// int p_nGeneSelType; genetic selection type; 0, setup children's reliability of cue from non-parents; 1, setup children's reliability of cue from parents;
0.001	// double p_dLearnAbiLow; lower bound of CueReliab;
1.0	// double p_dLearnAbiUp; upper bound of CueReliab;
0.05	// double p_dMutRate; mutation rate;
0.1	// double p_dMutStep; mutation step;
// when p_nComMode=7, MemLang RandCom;
1	// int p_nMemMutStep; mutation step for memory capacity; other parameters used: p_nGATimeScale, p_nCulSelType, p_nGeneSelType, p_dMutRate; also change p_nVarLTMem to 1 and adjust p_nMaxLexRuleVar, p_nMaxSynRuleVar, and p_nMaxCatVar;
4	// int p_nMemMutType; -1, default value; 0, no mutation; 1, IMMem mutation, adjust p_nMaxNumCombOption; 2, LTMem mutation, adjust p_nMaxLexRule, p_nMaxCat, and p_nMaxSynRule; 3, Buffer mutation, adjust p_nMaxBufSize; 4, LexRule mutation, adjust p_nMaxLexRule; 5, Cat mutation, adjust p_nMaxCat; 6, SynRule mutation, adjust p_nMaxSynRule;
// For whole system;	
100	// int p_nNumCom;
20	// int p_nNumInfoChange;
0	// int p_nCalAmbiguity; whether calculate ambiguity;
0	// int p_nRecMem; whether record memory capacity;
0	// int p_nShowComInfo; 0, do not show communication information (speaker or listener); 1, show such information;
// whether record individual's information;
1	// int p_nIndURCalMethod; method to calculate individual UR; 0, individual as listener; 1, individual as speaker;
0	// int p_nRecIndInfo; whether record each agent's lexical rules, syntactic rules and syntactic categories;
0	// int p_nRecURiniser; whether record URini and URser;