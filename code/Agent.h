// Agent.h: define language user;

// ---- Include Files;
#include"Memory.h"



// ---- Define CAgent class
class CAgent
{ // private members;
  private:
	int m_nIndex;		// index; -1, initialize value;
	int m_nGroupIndex;	// group index;
	int m_nLocX, m_nLocY;	// x and y location;
	double m_dChildAdultAbiRatio;	// children and adult's learnability and creativity's ratio;
	int m_nOnlyHolist;	// 0, allow agents to create compositional rules; 1, allow agents only create holistic rules;
	double m_dRandCrtRateWord; double m_dRandCrtRatePhrase; double m_dRandCrtRateHolist;
	double m_dDetRecPatRate;
	int m_nNoDetRecPatExm;	// number of M-U mappings which share the recurrent pattern to allow detecting this recurrent pattern;
	int m_nNoAcqCatSynExm;	// number of M-U mappings which share same use of lexical rules to allow building categories and syntactic rules; 
	double m_dDetLocOrdRate;
	double m_dCueReliabAg;	// cue reliability, this parameter is not in the parameter list, it can be changed;
	int m_nFeedbackTyp;
	double m_dSlope; double m_dHardFeedback;
	int m_nHandleFailedTyp;	// -1, initial value;
		// 0, in Suc, increase m_ppOptionComb[0], decrease m_ppOptionComb[i]; in Fail, decrease m_ppOptionComb[0], increase m_ppOptionComb[i];
		// 1, in Suc, increase m_ppOptionComb[0]; in Fail, decrease m_ppOptionComb[0];
		// 2, in Suc, increase m_ppOptionComb[0], decrease m_ppOptionComb[i]; in Fail, decrease m_ppOptionComb[0];
	int m_nAvoidLexFlag;	int m_nAvoidSynFlag;
	int m_nHandleBuf;	// handle buffer; 0, acqlexcat after each communication; 1, acqlexcat when the buffer is full;
	// communication interface;
	CMeanUtter *m_pMeanUtter; CCue *m_pCues;
	// memory system;
	CSemSpace *m_pSemSpace; CBuffer *m_pBuffer; CLTMem *m_pLTMem; CIMMem *m_pIMMem;
	// adjust mode;
	int m_nAdjMode;	// -1, default value; 0, linear; 1, nonlinear;
	// perspective;
	int m_nTakePersp;	// whether take perspective or not; -1, default; 0, no take; 1, take specific; 2, random take;
	int m_nPerspective;	// perspective influencing the local order rule creation; -1, default; 
			// 0, accusative-nominative, agent-perspective; OV orders are difference from SV orders;
			// 1, ergative-absolutive, patient-perspective; OV orders are same as SV orders;
	int m_nForget;	// 0, no forgetting; 1, forgetting;
	int m_nPredCase;	// 0, merge Pred1 and Pred2; 1, do not merge Pred1 and Pred2;
  // public membership functions;
  public:
	// overload new and delete;
  	//static void * operator new (size_t size) { return GlobalAlloc(GMEM_FIXED, size); };
	//static void operator delete (void *p) { GlobalUnlock(p); GlobalFree(p); };
	CAgent();	// construction function;
	CAgent(const CAgent &init);	// copy construction function;
	~CAgent();	// destruction function;
	CAgent & operator = (const CAgent &right);	// copy agent;  	
  	void initLearnAbi();	// initialize agent's learning abilities;
	void destLearnAbi();	// destroy agent's learning abilities;
	void InitAgent();	// initialization function;
  	void DestAgent();	// destroy function;
	// inline retrieve and change private members;
	inline int getIndex() { return m_nIndex; };
	inline void setIndex(int index) { assert(index>=-1); m_nIndex=index; };
	inline int getGroupIndex() { return m_nGroupIndex; };
	inline void setGroupIndex(int groupindex) { assert(groupindex>=-1); m_nGroupIndex=groupindex; };
	inline int getLocX() { return m_nLocX; };
	inline void setLocX(int LocX) { assert(LocX>=-1); m_nLocX=LocX; };
	inline int getLocY() { return m_nLocY; };
	inline void setLocY(int LocY) { assert(LocY>=-1); m_nLocY=LocY; };
	inline double getChildAdultAbiRatio() { return m_dChildAdultAbiRatio; };
	inline void setChildAdultAbiRatio(double ChildAdultAbiRatio) { assert((FLOAT_SM_EQ(0.0, ChildAdultAbiRatio))&&(FLOAT_SM_EQ(ChildAdultAbiRatio, 1.0))); m_dChildAdultAbiRatio=ChildAdultAbiRatio; };
	inline int getOnlyHolist() { return m_nOnlyHolist; };
	inline void setOnlyHolist(int OnlyHolist) { assert((OnlyHolist==-1)||(OnlyHolist==0)||(OnlyHolist==1)); m_nOnlyHolist=OnlyHolist; };
	inline double getRandCrtRateWord() { return m_dRandCrtRateWord; };
	inline void setRandCrtRateWord(double RandCrtRateWord) { assert((FLOAT_EQ(RandCrtRateWord, -1.0))||((FLOAT_SM_EQ(0.0, RandCrtRateWord))&&(FLOAT_SM_EQ(RandCrtRateWord, 1.0)))); m_dRandCrtRateWord=RandCrtRateWord; };
	inline double getRandCrtRatePhrase() { return m_dRandCrtRatePhrase; };
	inline void setRandCrtRatePhrase(double RandCrtRatePhrase) { assert((FLOAT_EQ(RandCrtRatePhrase, -1.0))||((FLOAT_SM_EQ(0.0, RandCrtRatePhrase))&&(FLOAT_SM_EQ(RandCrtRatePhrase, 1.0)))); m_dRandCrtRatePhrase=RandCrtRatePhrase; };
	inline double getRandCrtRateHolist() { return m_dRandCrtRateHolist; };
	inline void setRandCrtRateHolist(double RandCrtRateHolist) { assert((FLOAT_EQ(RandCrtRateHolist, -1.0))||((FLOAT_SM_EQ(0.0, RandCrtRateHolist))&&(FLOAT_SM_EQ(RandCrtRateHolist, 1.0)))); m_dRandCrtRateHolist=RandCrtRateHolist; };
	inline double getDetRecPatRate() { return m_dDetRecPatRate; };
	inline void setDetRecPatRate(double DetRecPatRate) { assert((FLOAT_EQ(DetRecPatRate, -1.0))||((FLOAT_SM_EQ(0.0, DetRecPatRate))&&(FLOAT_SM_EQ(DetRecPatRate, 1.0)))); m_dDetRecPatRate=DetRecPatRate; };
	inline int getNoDetRecPatExm() { return m_nNoDetRecPatExm; };
	inline void setNoDetRecPatExm(int NoDetRecPatExm) { assert(NoDetRecPatExm>=2); m_nNoDetRecPatExm=NoDetRecPatExm; };
	inline int getNoAcqCatSynExm() { return m_nNoAcqCatSynExm; };
	inline void setNoAcqCatSynExm(int NoAcqCatSynExm) { assert(NoAcqCatSynExm>=2); m_nNoAcqCatSynExm=NoAcqCatSynExm; };
	inline double getDetLocOrdRate() { return m_dDetLocOrdRate; };
	inline void setDetLocOrdRate(double DetLocOrdRate) { assert((FLOAT_EQ(DetLocOrdRate, -1.0))||((FLOAT_SM_EQ(0.0, DetLocOrdRate))&&(FLOAT_SM_EQ(DetLocOrdRate, 1.0)))); m_dDetLocOrdRate=DetLocOrdRate; };
	inline double getCueReliabAg() { return m_dCueReliabAg; };
	inline void setCueReliabAg(double newCueReliabAg) { assert((FLOAT_SM_EQ(0.0, newCueReliabAg))&&(FLOAT_SM_EQ(newCueReliabAg, 1.0))); m_dCueReliabAg=newCueReliabAg; };
	inline int getFeedbackTyp() { return m_nFeedbackTyp; };
	inline void setFeedbackTyp(int FeedbackTyp) { assert((-1<=FeedbackTyp)&&(FeedbackTyp<=1)); m_nFeedbackTyp=FeedbackTyp; };
	inline double getSlope() { return m_dSlope; };
	inline void setSlope(double Slope) { assert(FLOAT_BG_EQ(Slope, 0.0)); m_dSlope=Slope; };
	inline double getHardFeedback() { return m_dHardFeedback; };
	inline void setHardFeedback(double HardFeedback) { assert(FLOAT_BG_EQ(HardFeedback, 0.0)); m_dHardFeedback=HardFeedback; };
	inline int getHandleFailedTyp() { return m_nHandleFailedTyp; };
	inline void setHandleFailedTyp(int HandleFailedTyp) { assert((-1<=HandleFailedTyp)&&(HandleFailedTyp<=2)); m_nHandleFailedTyp=HandleFailedTyp; };
	inline int getAvoidLexFlag() { return m_nAvoidLexFlag; };
	inline void setAvoidLexFlag(int AvoidLexFlag) { assert((-1<=AvoidLexFlag)&&(AvoidLexFlag<=1)); m_nAvoidLexFlag=AvoidLexFlag; };
	inline int getAvoidSynFlag() { return m_nAvoidSynFlag; };
	inline void setAvoidSynFlag(int AvoidSynFlag) { assert((-1<=AvoidSynFlag)&&(AvoidSynFlag<=1)); m_nAvoidSynFlag=AvoidSynFlag; };
	inline int getHandleBuf() { return m_nHandleBuf; };
	inline void setHandleBuf(int HandleBuf) { assert((-1<=HandleBuf)&&(HandleBuf<=1)); m_nHandleBuf=HandleBuf; };
	// communication interface;
	inline CMeanUtter * getpMeanUtter() { return m_pMeanUtter; };
	inline void setpMeanUtter(CMeanUtter *meanutter) { m_pMeanUtter=meanutter; };
	inline CCue * getpCues() { return m_pCues; };
	inline void setpCues(CCue *cues) { m_pCues=cues; };
	// memory system;
	inline CSemSpace *getpSemSpace() { return m_pSemSpace; };
	inline void setpSemSpace(CSemSpace *semspace) { m_pSemSpace=semspace; };
	inline CBuffer * getpBuffer() { return m_pBuffer; };
	inline void setpBuffer(CBuffer *buffer) { m_pBuffer=buffer; };
	inline CLTMem * getpLTMem() { return m_pLTMem; };
	inline void setpLTMem(CLTMem *ltmem) { m_pLTMem=ltmem; };
	inline CIMMem * getpIMMem() { return m_pIMMem; };
	inline void setpIMMem(CIMMem *immem) { m_pIMMem=immem; };
	inline int getAdjMode() { return m_nAdjMode; };
	inline void setAdjMode(int adjmode) { assert((-1<=adjmode)&&(adjmode<=1)); m_nAdjMode=adjmode; };
	inline int getTakePersp() { return m_nTakePersp; };
	inline void setTakePersp(int takePersp) { assert((-1<=takePersp)&&(takePersp<=2)); m_nTakePersp=takePersp; };
	inline int getPerspective() { return m_nPerspective; };
	inline void setPerspective(int perspective) { assert((-1<=perspective)&&(perspective<=1)); m_nPerspective=perspective; };
	inline int getForget() { return m_nForget; };
	inline void setForget(int forget) { assert((forget==-1)||(forget==0)||(forget==1)); m_nForget=forget; };
	inline int getPredCase() { return m_nPredCase; };
	inline void setPredCase(int PredCase) { assert((PredCase==-1)||(PredCase==0)||(PredCase==1)); m_nPredCase=PredCase; };
	// other operations;
	// production part;
	// build up OptionComb;
	void setCombHolist(int meantype, int type, int subtype, CLexRule **&CandLexRule, int *numCandLexRule, int *numHolist); // use holistic or rand holist rules;void BldComb1(int type, int subtype, CLexRule **CandLexRule, int *numCandLexRule, int *numHolist, int *numAg, int *numPred);	// build up OptionComb for "Predicate<Agent>" meanings;
	int SelWinIndex();	// select winindex from m_ppOptionComb;
	void fillOptPro1(int meantype, int type, int subtype, CLexRule *rule, CatList *catlist); // fill in optiontemp with 1 word rule or 1 phrase rule;
	void fillOptPro2(int meantype, int type, int subtype, CLexRule *rule1, CLexRule *rule2, CatList *catlist1, CatList *catlist2, CSynRule *syn12); // fill in optiontemp with 2 word rules;
	void fillOptPro3(int meantype, int type, int subtype, CLexRule *rule1, CLexRule *rule2, CLexRule *rule3, CatList *catlist1, CatList *catlist2, CatList *catlist3, CSynRule *syn12, CSynRule *syn23, CSynRule *syn13);	// fill in optiontemp with 3 word rules;
	// "Predicate<Agent>" meanings;
	void setComb1Word1(int meantype, int type, int subtype, CLexRule **&CandLexRule, int *numCandLexRule, int *numHolist, int *numAg, int *numPred); // use 1 word + 1 rand word rules;
 	void setComb2Word1(int meantype, int type, int subtype, CLexRule **&CandLexRule, int *numCandLexRule, int *numHolist, int *numAg, int *numPred); // use 2 word rules;
	void BldComb1(int type, int subtype, CLexRule **&CandLexRule, int *numCandLexRule, int *numHolist, int *numAg, int *numPred); // build up OptionComb for "Predicate<Agent>" meanings;
	void SetCand1(int meantype, CLexRule **&CandLexRule, int *numCandLexRule, int *numHolist, int *numAg, int *numPred);	// decide how many ways to express "Predicate<Agent>" meaning, and record related lexical rules/categories/syntactic rules into IMMem;
	// "Predicate<Agent, Patient>" meanings;
	void setCombWordPhrase2(int meantype, int type, int subtype, CLexRule **&CandLexRule, int *numCandLexRule, int *numHolist, int *numAg, int *numPred, int *numPat, int *numAgPred, int *numAgPat, int *numPredPat); // use 1 word + 1 phrase rule;
	void setComb3Word2(int meantype, int type, int subtype, CLexRule **&CandLexRule, int *numCandLexRule, int *numHolist, int *numAg, int *numPred, int *numPat, int *numAgPred, int *numAgPat, int *numPredPat); // use 3 word rules;
	void setCombPhrase2(int meantype, int type, int subtype, CLexRule **&CandLexRule, int *numCandLexRule, int *numHolist, int *numAg, int *numPred, int *numPat, int *numAgPred, int *numAgPat, int *numPredPat); // use 1 phrase + 1 rand word rules;
	void setComb2Word2(int meantype, int type, int subtype, CLexRule **&CandLexRule, int *numCandLexRule, int *numHolist, int *numAg, int *numPred, int *numPat, int *numAgPred, int *numAgPat, int *numPredPat); // use 2 word + 1 rand word rules;
	void setComb1Word2(int meantype, int type, int subtype, CLexRule **&CandLexRule, int *numCandLexRule, int *numHolist, int *numAg, int *numPred, int *numPat, int *numAgPred, int *numAgPat, int *numPredPat); // use 1 word + 1 rand phrase rule;
	void BldComb2(int type, int subtype, CLexRule **&CandLexRule, int *numCandLexRule, int *numHolist, int *numAg, int *numPred, int *numPat, int *numAgPred, int *numAgPat, int *numPredPat);	// build up OptionComb for "Predicate<Agent, Patient>" meanings;
	void SetCand2(int meantype, CLexRule **&CandLexRule, int *numCandLexRule, int *numHolist, int *numAg, int *numPred, int *numPat, int *numAgPred, int *numAgPat, int *numPredPat);	// decide how many ways to express "Predicate<Agent, Patient>" meaning, and record related lexical rules/categories/syntactic rules into IMMem;
	void Case2(CCat *newCat1, CCat *newCat2, CSynRule *newSyn1);	// Case 2: 2 cats, 1 syn;
	void Case345(int type, CCat *newCat1, CCat *newCat2, CSynRule *newSyn1);	// case 3: 1 cat(cat1), 0 syn; case 4: 1 cat(cat2), 0 syn; case 5: 0 cat, 0 syn;
	void StoreCatSyn(CCat *&newCat1, CCat *&newCat2, CSynRule *&newSyn1);	// store newCat1-2, newSyn1 into LTMem;
	void StoreWordPhraCatSyn(CLexRule *&newWordPhra, CCat *&newCat1, CCat *&newCat2, CSynRule *&newSyn1);	// store newWord/newPhrase, newCat1-2, newSyn1 into LTMem;
	// different cases in StoreCat123Syn123;
	void Case567(int type, int index, CCat *newCat1, CCat *newCat2, CCat *newCat3, CSynRule *newSyn1, CSynRule *newSyn2);	// case 5: 3 cats, 1 syn(12); case 6: 3 cats, 1 syn(23); case 7: 3 cats, 1 syn(13);
	void Case8(int index, CCat *newCat1, CCat *newCat2, CCat *newCat3, CSynRule *newSyn1, CSynRule *newSyn2);	// case 8: 3 cats, 0 syn;
	void Case91113(int type, int index, CCat *newCat1, CCat *newCat2, CCat *newCat3, CSynRule *newSyn1, CSynRule *newSyn2);	// case 9: 2 cats(cat1, cat2), 1 syn(12); case 11: 2 cats(cat1, cat3), 1 syn(13); case 13: 2 cats(cat2, cat3), 1 syn(23);
	void Case101214(int type, int index, CCat *newCat1, CCat *newCat2, CCat *newCat3, CSynRule *newSyn1, CSynRule *newSyn2);	// case 10: 2 cats(cat1, cat2), 0 syn;
	void Case151617(int type, int index, CCat *newCat1, CCat *newCat2, CCat *newCat3, CSynRule *newSyn1, CSynRule *newSyn2);	// case 15: 1 cat(cat1), 0 syn; case 16: 1 cat(cat2), 0 syn; case 17: 1 cat(cat3), 0 syn;
	void Case18(int index, CCat *newCat1, CCat *newCat2, CCat *newCat3, CSynRule *newSyn1, CSynRule *newSyn2);	// case 18: 0 cat, 0 syn;
	void StoreCat123Syn123(CCat *&newCat1, CCat *&newCat2, CCat *&newCat3, CSynRule *&newSyn1, CSynRule *&newSyn2, CSynRule *&newSyn3);	// store newCat1-3, newSyn1-3 to LTMem;
	void StoreWordCat123Syn12(CLexRule *&newWord, CCat *&newCat1, CCat *&newCat2, CCat *&newCat3, CSynRule *&newSyn1, CSynRule *&newSyn2);	// store newWord, newCat1-3, newSyn1-2 into LTMem;
	void SetUtter(CMeanUtter *meanutter, int NormOrTest);	// set up utterance for the chosen meaning; 
	void SelWinSetUtter(CMeanUtter *meanutter, int NormOrTest);	// select winning rules and build up utterance from it;
	void ChoMeantoPro(CMeanUtter *meanutter, int NormOrTest, int meanindex);	// select meaning for production;
  	void Production(CMeanUtter *meanutter, int NormOrTest);	// produce mean's utter in meanutter; if failed to produce, meanutter->m_pUtter[]=-1; NormOrTest=0, normal communication; 1, testing;
	// perception part;
	void setFeedBack(double winrulestr, int *feedback, bool *inBufSuc, int NormOrTest);	// according to winrulestr, set up feedback;
	int chkCues(int type, int subtype, CLexRule *lexrule1, CLexRule *lexrule2, CLexRule *lexrule3);	// check whether certain cues match the lexical rules;
		// type=1, holistic rule; 
  			// subtype=0;
  		// type=2, 2 word rules for "Predicate<Agent>" meaning;
 			// subtype=0;
  		// type=3, 1 word rule for "Predicate<Agent>" meaning; 
 			// subtype=1, Ag; subtype=2, Pred1;
  		// type=4, 3 word rules for "Predicate<Agent, Patient>" meaning; 
  			// subtype=0; 
  		// type=5, 1 word + 1 phrase rules for "Predicate<Agent, Patient>" meanings; 
  			// subtype=1, Ag + PredPat; 2, Pred2 + AgPat; 3, Pat + AgPred;
  		// type=6, 2 word rules for "Predicate<Agent, Patient>" meaning; 
  			// subtype=1, Ag + Pred2; 2, Ag + Pat; 3, Pred2 + Pat;
  		// type=7, 1 phrase rule for "Predicate<Agent, Patient>" meaning; 
  			// subtype=1, AgPred; 2, AgPat; 3, PredPat; 
  		// type=8, 1 word rule for "Predicate<Agent, Patient>" meaning; 
  			// subtype=1, Ag; 2, Pred2; 3, Pat;
  		// for complete rules (type=1, 2, 4, 5), check all cues no matter they are used by other complete rules;
  		// for incomplete rules (type=3, 6, 7, 8), only check cues with !0 strength;
  	void bltMeanUtter(CMeanUtter *meanutter, int type, int subtype, CLexRule *lexrule1, CLexRule *lexrule2, CLexRule *lexrule3);	// build up meanutter using lexical rules;
   		// type=1, 2 word rules for "Predicate<Agent>" meaning;
  			// subtype=0;
  		// type=2, 3 word rules for "Predicate<Agent, Patient>" meaning;
  			// subtype=0;
  		// type=3, 1 word rule + 1 phrase rule for "Predicate<Agent, Patient>" meaning;
  			// subtype=1, Ag + PredPat;
  			// subtype=2, Pred2 + AgPat;
  			// subtype=3, Pat + AgPred;
	void fillOptPer1(int cond, int type, int cueindex, CLexRule *matlexrule, CatList *catlist);	// fill in optiontemp with 1 word rule or 1 phrase rule;
 	void fillOptPer2(int NormOrTest, int cond, int type, int subtype, CLexRule *matlexrule1, CLexRule *matlexrule2, CatList *catlist1, CatList *catlist2, CSynRule *syn12);	// update categories, syntactic rules and lingstr using 2 rules;
	void fillOptPer3(int NormOrTest, int type, CLexRule *matlexrule1, CLexRule *matlexrule2, CLexRule *matlexrule3, CatList *catlist1, CatList *catlist2, CatList *catlist3, CSynRule *syn12, CSynRule *syn23, CSynRule *syn13);	// update categories, syntactic rules and combine strength using 3 word rules;
   	void updCandMeanUtter(CMeanUtter *meanutter, CMeanUtter **&CandMeanUtter, int *numCandMeanUtter);	// update CandMeanUtter;
	// for complete SV or SVO meanings;
	void BldCombPerHolist(int NormOrTest, CMeanUtter **&CandMeanUtter, int *numCandMeanUtter, CLexRule *matlexrule);	// check whether certain cue matches the matlexrule and build m_pIMMem->CombOption;
	void BldCombPerSV2word(int NormOrTest, CMeanUtter **&CandMeanUtter, int *numCandMeanUtter, int type, CLexRule *matlexrule1, CLexRule *matlexrule2);	// check whether certain cue matches 2 SV word rules and build up CombOption; type=1(SV); 2(VS);
  	void BldCombPerSVO3word(int NormOrTest, CMeanUtter **&CandMeanUtter, int *numCandMeanUtter, int type, CLexRule *matlexrule1, CLexRule *matlexrule2, CLexRule *matlexrule3);	// check whether certain cue matches 3 SVO word rules and build up CombOption; type=3(SVO); 4(SOV); 5(OSV); 6(VSO); 7(VOS); 8(OVS);
	void BldCombPerSVOwordphra(int NormOrTest, CMeanUtter **&CandMeanUtter, int *numCandMeanUtter, int type, CLexRule *matlexrule, CLexRule *matphrarule);	// check whether certain cue matches 1 word + 1 phrase rules and build up CombOption; type=9(S+VO/OV); 10(VO/OV+S); 11(V(S)O or O(S)V); 12(V+SO/OS); 13(SO/OS+V); 14(S(V)O or O(V)S); 15(O+SV/VS); 16(SV/VS+O); 17(S(O)V or V(O)S);
	// for incomplete SV or SVO meanings;
	void BldCombPerSV1word(CMeanUtter **&CandMeanUtter, int *numCandMeanUtter, int type, CLexRule *matlexrule);	// check whether certain cue matches 1 SV word rules and build up CombOption; type=0(Ag); 1(Pred1);
	void BldCombPerSVO2word(CMeanUtter **&CandMeanUtter, int *numCandMeanUtter, int type, CLexRule *matlexrule1, CLexRule *matlexrule2);	// for remaining 2 SVO word rules; check whether certain cue matches it; type=2(SV); 3(VS); 4(SO); 5(OS); 6(VO); 7(OV);
	void BldCombPerSVO1phra(CMeanUtter **&CandMeanUtter, int *numCandMeanUtter, int type, CLexRule *matphrarule);	// for remaining 1 phrase rules; check whether certain cue matches it; type=8(AgPred); 9(AgPat); 10(PredPat);
	void BldCombPerSVO1word(CMeanUtter **&CandMeanUtter, int *numCandMeanUtter, int type, CLexRule *matlexrule);	// for remaining 1 SVO word rules; check whether certain cue matches it; type=11(Ag); 12(Pred2); 13(Pat);
	// for cues only;
	void BldCombPerCues(CMeanUtter **&CandMeanUtter, int *numCandMeanUtter);	// for remaining cues;
  	void SetCombMat(int NormOrTest, MatLexRule **&MatchLexRule, int *numMatchLexRule, CMeanUtter **&CandMeanUtter, int *numCandMeanUtter, int *numHolist, int *numAg, int *numPred1, int *numPred2, int *numPat, int *numAgPred, int *numAgPat, int *numPredPat);	// select combinable rules from matched rules, and record related lexical rules/categories/syntactic rules into IMMem;
	void SelWinSetMean(CMeanUtter *meanutter, CMeanUtter **&CandMeanUtter, int *numCandMeanUtter);	// select winning rules and build up meaning from it;
	void Perception(CMeanUtter *meanutter, int *feedback, bool *inBufSuc, int NormOrTest); // percept mean based on meanutter's utter; if failed to produce, meanutter->m_pMean[]=-1; NormOrTest=0, normal communication; 1, testing UR; 2, testing Disp; 3, in vertical transmission, listener always get the correct cue;
	void getReal_PotOrdTyp(int recLocOrdtype, CMeanUtter *meanutter, int OptionCombInd, int *OrdTyp1, int *OrdTyp2, double *LocSynStr, int size);	// test which order agent used to produce/comprehend; 0(SV), 1(VS), 2(SVO), 3(SOV), 4(OSV), 5(VSO), 6(VOS), 7(OVS);
	// update part;
	void AdjIMMem(bool SucFail);	// adjust m_pIMMem based on SucFail;
	void UpdIMMem(int feedback);	// after one information exchange, based on feedback, update winning/losing rules/categories/syntactic rules; 
	// acquire new rules part;
	void DecMUinBuf(CandMU **&newCandMU, int numCandMU);	// decompose M-U mappings in buffer and store indecomposible M-U mappings as holistic rules into lexical rule list;
	void decMUinHolist();	// decompose holistic rule in LTMem;
	void decMUinPhrase();	// decompose phrase rule in LTMem;
	void DecLex();	// decompose holistic and phrase rules;
 	void DetRecPat(int type);	// detection of recurrent pattern for acquiring new lexical rules; type=1, detect recurrent pattern after every communication; type=2, detect recurrent pattern when the buffer is full;
	void AcqCat();	// acquire new categories and syntactic rules;
	void AcqLexCatSyn(CMeanUtter *MU, int feedback, bool inBufSuc);	// after one information exchange, gather information;
	// forgetting;
	double calRatio();	// calculate the ratio for forgetting, using linear curve between number of lexical rules and the ratio (01. to 1.0) of forgetting rate;
	void Forget();	// forget lexical rules, categories and syntactic rules;
};
