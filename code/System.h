// SystemClass.h: define main scenarios and test performance;

// ---- Include Files;
#include"Agent.h"



// ---- Define CSystemClass class
class CSystem
{ // private members;
  private:
	int m_nNumAgent; CAgent **m_ppAgent, **m_ppAgent1, **m_ppAgentN;	// m_ppAgent1 and m_ppAgentN temporarily store m_ppAgent;
	int m_nCheckFre;	// total number of sample points;
	int m_nDecFlag;	// whether decopose holistic/phrase rule (1) or not (0); -1: initial value;
	int m_nSelfTalkFlag;	// whether self-talk is allowed (1) or not (0); -1: initial value;
	int m_nRecLocOrdNo_Str;	// whether record local order's number used (0) or strength (1);
	
	int m_nComMode;	// communication mode: -1, initial value; 0, randomcom; 1, paircom; 2, teach-learn; 3, popagent; 4, 2D world; 5, SolCom; 6, GA RandCom; 7, MemLang RandCom; 8, Lang-JA&LTM coevolution;
	int m_nNumGroup;	// 1, one group; 2, two groups;

	int m_nG1HolComp;	// -1, default value; 0, holistic; 1, compo, local orders by p_nG1order; 2, compo, local orders by p_nG1SV/p_nG1VS/p_nG1VO/p_nG1OV/p_nG1SO/p_nG1OS;
	int m_nG1CompTyp;	// -1, default value; 0, random create compositional rules' utterance, allow homonyms; 1, do not allow homonyms; 2, use identical meaning as utterance syllable; 
	int m_nG1InitCompCat;	// -1, default value; 0, predicate category covers all predicates; 1, there are 2 predicate categories;
	int m_nG1order1;	// if((m_nG1HolComp==1)&&(m_nG1InitCompCat==1)) group1's "Pred<Ag>" meanings local order; 0, default value; 1, SV; 2, VS;
	int m_nG1order2;	// if((m_nG1HolComp==1)&&(m_nG1InitCompCat==0/1)) group1's "Pred<Ag, Pat>" meanings local order; 0, default value; 1, SVO; 2, SOV; 3, OSV; 4, VSO; 5, VOS; 6, OVS;
	int m_nG1SV1;	// if((m_nG1HolComp==2)&&(m_nG1InitCompCat==1)) 0, no SV local order; 1, SV local order for "Pred<Ag>" meanings;
	int m_nG1VS1;	// if((m_nG1HolComp==2)&&(m_nG1InitCompCat==1)) 0, no VS local order; 1, VS local order for "Pred<Ag>" meanings;
	int m_nG1SV;	// 0, no SV local order; 1, SV local order;
	int m_nG1VS;	// 0, no VS local order; 1, VS local order;
	int m_nG1VO;	// 0, no VO local order; 1, VO local order;
	int m_nG1OV;	// 0, no OV local order; 1, OV local order;
	int m_nG1SO;	// 0, no SO local order; 1, SO local order;
	int m_nG1OS;	// 0, no OS local order; 1, OS local order;

	double m_dG1LexNhomrate;
	double m_dG1LexVhomrate;
	double m_dG1LexNVhomrate;

	int m_nG2HolComp;	// -1, default value; 0, holistic; 1, compo, local orders by p_nG2order; 2, compo, local orders by p_nG2SV/p_nG2VS/p_nG2VO/p_nG2OV/p_nG2SO/p_nG2OS; 
	int m_nG2CompTyp;	// -1, default value; 0, random create compositional rules' utterance, allow homonyms; 1, do not allow homonyms; 2, use identical meaning as utterance syllable; 
	int m_nG2InitCompCat;	// -1, default value; 0 predicate category covers all predicates; 1, there are 2 predicate categories;
	int m_nG2order1;	// if((m_nG2HolComp==1)&&(m_nG2InitCompCat==1)) group2's "Pred<Ag>" meanings local order; 0, default value; 1, SV; 2, VS;
	int m_nG2order2;	// if((m_nG2HolComp==1)&&(m_nG2InitCompCat==0/1)) group2's "Pred<Ag, Pat>" meanings local order; 0, default value; 1, SVO; 2, SOV; 3, OSV; 4, VSO; 5, VOS; 6, OVS;
	int m_nG2SV1;	// if((m_nG2HolComp==2)&&(m_nG2InitCompCat==1)) 0, no SV local order; 1, SV local order for "Pred<Ag>" meanings;
	int m_nG2VS1;	// if((m_nG2HolComp==2)&&(m_nG2InitCompCat==1)) 0, no VS local order; 1, VS local order for "Pred<Ag>" meanings;
	int m_nG2SV;	// 0, no SV local order; 1, SV local order;
	int m_nG2VS;	// 0, no VS local order; 1, VS local order;
	int m_nG2VO;	// 0, no VO local order; 1, VO local order;
	int m_nG2OV;	// 0, no OV local order; 1, OV local order;
	int m_nG2SO;	// 0, no SO local order; 1, SO local order;
	int m_nG2OS;	// 0, no OS local order; 1, OS local order;

	double m_dG2LexNhomrate;
	double m_dG2LexVhomrate;
	double m_dG2LexNVhomrate;

	double m_dLexSim;	// for 2 groups, lexical rules similarity, for syntactic rules, use G1order and G2order to adjust;

	int m_nHorObliMix;	// 0, horizontal transmission only; 1, oblique transmission only; 2, mixed horizontal and oblique transmission;
	int m_nMixHorVer;	// 0, no mix horizontal and vertical transmission; 1, mixed horizontal and vertical transmission;
	int m_nNumAgentRep;	// number of agents replaced every generation;

	int m_nCalTransMethod;	// -1, default value; 0, calculate using m_dAdultChildRatio, m_dChildChildRation, m_dChildAdultRatio, and m_dVerProb; 1, calculate using m_dPCRatio, m_dACRatio, m_dCCRatio, and m_dCARatio; 2, calculate using m_dGrandChildRatio, m_dParentChildRatio, and m_dChildChildRatio;

	double m_dAdultChildRatio;	// probability for adult-child communication;
	double m_dChildChildRatio;	// probability for child-child communication;
	double m_dChildAdultRatio;	// probability for child-adult communication; m_dAdultChildRatio+m_dChildChildRatio+m_dChildAdultRatio=1.0;
	double m_dVerProb;	// probability for bio-parent teaches to the newAgent;

	double m_dPCRatio;	// probability for bioparent-child communication;
	double m_dACRatio;	// probability for nonbioparent-child communication;
	double m_dCCRatio;	// probability for child-child communication;
	double m_dCARatio;	// probability for child-adult communication; m_dPCRatio+m_dACRatio+m_dCCRatio+m_dCARatio=1.0;

	double m_dGrandCRatio;	// probability for grandparent-child communication;
	double m_dParentCRatio;	// probability for parent-child communication;
	double m_dChildCRatio;	// probability for child-child communication; m_dGrandCRatio+m_dParentCRatio+m_dChildCRatio=1.0;
	int m_nGrandCType;	// 0, grandparents only talk to direct grandoffspring; 1, grandparents talk to any grandchildren;
	int m_nParentCType;	// 0, parents only talk to direct offspring; 1, parents talk to any children;

	int m_nVerTranRandCrt; int m_nVerTranWrongCue;
	int m_nDifAdultChild;	// 0, no difference; 1, child and adult have different level of linguistic abilities;
	double m_dDifRatio;	// 1.0, no difference; the ratio between adult's ability and children's ability;
	int m_nSpUpd;	// 0, in oblique or vertical transmissions, speakers do not update their languages; 1, speakers occasionally update their languages;
	double m_dSpUpdProb;	// in oblique or vertical transmissions, the probability for speakers update their languages;

	int m_nNumGen; int m_nNumLearn;

	int m_nHumanChimp;	// 0, human society; 1, chimpanzee society with linear value of popularity; 2, chimpanzee society with scale value of popularity; 3, chimpanzee society with Power-law distribution; 4, speaker and listener have different Power-law distributions; 5, normal distribution with same mean and std of power-law distribution;
	double m_dA1;	// m_dA1*pow(x, m_dK1);
	double m_dK1;	// m_dA1*pow(x, m_dK1);
	double m_dA2;	// m_dA2*pow(x, m_dK2);
	double m_dK2;	// m_dA2*pow(x, m_dK2);
	double m_dScale;	// for p_nHumanChimp=2, the scale for popularity;
	double m_dPopRat;	// for 1 group, popular rate;
	double m_dIntraRat; double m_dInterRat;	// for 2 groups, intra and inter rate;

	int m_nWorldX, m_nWorldY;	// 2D world size;
	int m_nBlockDist;	// the distance within which agents can communicate with each other;
	double m_dSucRat;	// the percentage of "successful" infochange can bind two agents together; 
	int m_nSucCri;	// -1, default value; 0, using feedback to check success of communication; 1, using meaning to check success of communication;
	int m_nMoveStep;	// moving step; 0, default value;
	int m_n1toMCom;	// -1, default value; 0, normal one to one com; 1, one to many com;

	int m_nSelfGrow;	// 0, default network; 1, self-grow network based on degree; 2, self-grow network based on UR;

	int m_nGATimeScale;	// after how many communications let GA to adjust individual learning abilities;
	int m_nNumSp;	// number of speakers for children to learn from;
	int m_nCulSelType;	// cultural selection type; 0, randomlt select 50% agents; 1, select best 50% agents;
	int m_nGeneSelType;	// genetic selection type; 0, setup children's reliability of cue from non-parents; 1, setup children's reliability of cue from parents;
	double m_dLearnAbiLow;	// lower bound of CueReliab;
	double m_dLearnAbiUp;	// upper bound of CueReliab;
	double m_dMutRate;	// mutation rate;
	double m_dMutStep;	// mutation step;

	int m_nMemMutStep;	// mutation step for memory capacity; other parameters used: m_nGATimeScale, m_nCulSelType, m_nGeneSelType, m_dMutRate; also change p_nVarLTMem to 1 and adjust p_nMaxLexRuleVar, p_nMaxSynRuleVar, and p_nMaxCatVar;
	int m_nMemMutType;	// -1, default value; 0, no mutation; 1, IMMem mutation, adjust p_nMaxNumCombOption; 2, LTMem mutation, adjust p_nMaxLexRule, p_nMaxCat, and p_nMaxSynRule; 3, Buffer mutation, adjust p_nMaxBufSize; 4, LexRule mutation, adjust p_nMaxLexRule; 5, Cat mutation, adjust p_nMaxCat; 6, SynRule mutation, adjust p_nMaxSynRule; 7, multi-evolution, Buffer+ILMem+LTMem(LexRule);

	int m_nNumCom; 
	int m_nNumInfoChange;
	
	int m_nCalAmbiguity;	// whether calculate ambiguity;
	int m_nRecMem;	// whether record memory capacity;

	int m_nShowComInfo;	// 0, do not show communication information (speaker or listener); 1, show such information;

	int m_nIndURCalMethod;	// method to calculate individual UR; 0, individual as listener; 1, individual as speaker;
	int m_nRecIndInfo;	// whether record each agent's lexical rules, syntactic rules and syntactic categories;
	int m_nRecURiniser;	// whether record URini and URser;
		
  // membership functions;
  public:
	// overload new and delete;
  	//static void * operator new (size_t size) { return GlobalAlloc(GMEM_FIXED, size); };
	//static void operator delete (void *p) { GlobalUnlock(p); GlobalFree(p); };
	CSystem();	// construction function;
	CSystem(const CSystem &init);	// copy construction function;
	~CSystem();	// destruction function;
	CSystem & operator = (const CSystem &right);	// copy system;
	void selInitRuleLoc(int type, int Agindex, int *InitRuleLoc, int numInitRule);	// locate the initial shared rules location in SemSpace;
	void getLocalOrder(int type, int SVOorder, int *SVtype, int *VOtype, int *SOtype);	// translate SVOorder into local order;
	void InitLexCatSyn(int type, int groupInd, int Agindex, CMeanUtter **meanutter, int numMeanUtter);	// initialize m_ppAgent[Agindex]'s initial lexical rules, categories, and syntactic rules;
	void setGroupHolistRule(int groupInd, int lowBound, int upBound);	// m_ppAgent[lowBound] to m_ppAgent[upBound] share same holistic rules;
	void setGroupCompoRule(int groupInd, int lowBound, int upBound);	// m_ppAgent[lowBound] to m_ppAgent[upBound] share same holistic rules;
	void adjHom(int groupInd, int lowBound, int upBound);	// adjust homonym among lexical rules;
	void adjLexSim(int G1low, int G1up, int G2low, int G2up);	// adjust lexical rules similarity between two groups' languages;
	void InitRuleAll();	// initializing all agents with holistic/compo rules;
	void InitTeacher(int teacher);	// initialize m_ppAgent[teacher] with compositional rules;
	void InitAgentLoc();	// initialize agents' location;
	void setGroupIndex();	// set up group index for each agent;
	void InitSystem();	// initialization function;
	void DestSystem();	// destroy function;
	void copyAgent(CAgent *agent, CAgent *&agentCopy);	// copy agent to agentCopy;
	void updAgentN();	// update m_ppAgent into m_ppAgentN;
	// inline retrieve and change private members; copy by value;
	inline int getNumAgent() { return m_nNumAgent; };
	inline void setNumAgent(int numagent) { assert(numagent>=0); m_nNumAgent=numagent; };
	inline CAgent **getppAgent() { return m_ppAgent; };
	inline CAgent * getpAgent(int i) { assert((0<=i)&&(i<getNumAgent())); return m_ppAgent[i]; };
	inline void setpAgent(int i, CAgent *agent) { assert((0<=i)&&(i<getNumAgent())); m_ppAgent[i]=agent; };
	inline CAgent **getppAgent1() { return m_ppAgent1; };
	inline CAgent * getpAgent1(int i) { assert((0<=i)&&(i<getNumAgent())); return m_ppAgent1[i]; };
	inline void setpAgent1(int i, CAgent *agent) { assert((0<=i)&&(i<getNumAgent())); m_ppAgent1[i]=agent; };
	inline CAgent **getppAgentN() { return m_ppAgentN; };
	inline CAgent * getpAgentN(int i) { assert((0<=i)&&(i<getNumAgent())); return m_ppAgentN[i]; };
	inline void setpAgentN(int i, CAgent *agent) { assert((0<=i)&&(i<getNumAgent())); m_ppAgentN[i]=agent; };
	inline int getCheckFre() { return m_nCheckFre; };
	inline void setCheckFre(int checkfre) { assert(checkfre>=0); m_nCheckFre=checkfre; };
	inline int  getDecFlag() { return m_nDecFlag; };
	inline void setDecFlag(int decflag) { assert((decflag==-1)||(decflag==0)||(decflag==1)); m_nDecFlag=decflag; };
	inline int getSelfTalkFlag() { return m_nSelfTalkFlag; };
	inline void setSelfTalkFlag(int selftalkflag) { assert((selftalkflag==-1)||(selftalkflag==0)||(selftalkflag==1)); m_nSelfTalkFlag=selftalkflag; };
	inline int getRecLocOrdNo_Str() { return m_nRecLocOrdNo_Str; };
	inline void setRecLocOrdNo_Str(int RecLocOrdNo_Str) { assert((RecLocOrdNo_Str==-1)||(RecLocOrdNo_Str==0)||(RecLocOrdNo_Str==1)); m_nRecLocOrdNo_Str=RecLocOrdNo_Str; };
	inline int getComMode() { return m_nComMode; };
	inline void setComMode(int commode) { assert((-1<=commode)&&(commode<=8)); m_nComMode=commode; };
	inline int getNumGroup() { return m_nNumGroup; };
	inline void setNumGroup(int numGroup) { assert((0<=numGroup)&&(numGroup<=2)); m_nNumGroup=numGroup; };
	inline int getG1HolComp() { return m_nG1HolComp; };
	inline void setG1HolComp(int G1Holcomp) { assert((-1<=G1Holcomp)&&(G1Holcomp<=2)); m_nG1HolComp=G1Holcomp; };
	inline int getG1CompTyp() { return m_nG1CompTyp; };
	inline void setG1CompTyp(int G1CompTyp) { assert((-1<=G1CompTyp)&&(G1CompTyp<=2)); m_nG1CompTyp=G1CompTyp; };
	inline int getG1InitCompCat() { return m_nG1InitCompCat; };
	inline void setG1InitCompCat(int G1InitCompCat) { assert((-1<=G1InitCompCat)&&(G1InitCompCat<=1)); m_nG1InitCompCat=G1InitCompCat; };
	inline int getG1order1() { return m_nG1order1; };
	inline void setG1order1(int G1order1) { assert((0<=G1order1)&&(G1order1<=2)); m_nG1order1=G1order1; };
	inline int getG1order2() { return m_nG1order2; };
	inline void setG1order2(int G1order2) { assert((0<=G1order2)&&(G1order2<=6)); m_nG1order2=G1order2; };
	inline int getG1SV1() { return m_nG1SV1; };
	inline void setG1SV1(int G1SV1) { assert((G1SV1==0)||(G1SV1==1)); m_nG1SV1=G1SV1; };
	inline int getG1VS1() { return m_nG1VS1; };
	inline void setG1VS1(int G1VS1) { assert((G1VS1==0)||(G1VS1==1)); m_nG1VS1=G1VS1; };
	inline int getG1SV() { return m_nG1SV; };
	inline void setG1SV(int G1SV) { assert((G1SV==0)||(G1SV==1)); m_nG1SV=G1SV; };
	inline int getG1VS() { return m_nG1VS; };
	inline void setG1VS(int G1VS) { assert((G1VS==0)||(G1VS==1)); m_nG1VS=G1VS; };
	inline int getG1VO() { return m_nG1VO; };
	inline void setG1VO(int G1VO) { assert((G1VO==0)||(G1VO==1)); m_nG1VO=G1VO; };
	inline int getG1OV() { return m_nG1OV; };
	inline void setG1OV(int G1OV) { assert((G1OV==0)||(G1OV==1)); m_nG1OV=G1OV; };
	inline int getG1SO() { return m_nG1SO; };
	inline void setG1SO(int G1SO) { assert((G1SO==0)||(G1SO==1)); m_nG1SO=G1SO; };
	inline int getG1OS() { return m_nG1OS; };
	inline void setG1OS(int G1OS) { assert((G1OS==0)||(G1OS==1)); m_nG1OS=G1OS; };
	inline double getG1LexNhomrate() { return m_dG1LexNhomrate; };
	inline void setG1LexNhomrate(double G1LexNhomrate) { assert((FLOAT_SM_EQ(0.0, G1LexNhomrate))&&(FLOAT_SM_EQ(G1LexNhomrate, 1.0))); m_dG1LexNhomrate=G1LexNhomrate; };
	inline double getG1LexVhomrate() { return m_dG1LexVhomrate; };
	inline void setG1LexVhomrate(double G1LexVhomrate) { assert((FLOAT_SM_EQ(0.0, G1LexVhomrate))&&(FLOAT_SM_EQ(G1LexVhomrate, 1.0))); m_dG1LexVhomrate=G1LexVhomrate; };
	inline double getG1LexNVhomrate() { return m_dG1LexNVhomrate; };
	inline void setG1LexNVhomrate(double G1LexNVhomrate) { assert((FLOAT_SM_EQ(0.0, G1LexNVhomrate))&&(FLOAT_SM_EQ(G1LexNVhomrate, 1.0))); m_dG1LexNVhomrate=G1LexNVhomrate; };
	inline int getG2HolComp() { return m_nG2HolComp; };
	inline void setG2HolComp(int G2Holcomp) { assert((-1<=G2Holcomp)&&(G2Holcomp<=2)); m_nG2HolComp=G2Holcomp; };
	inline int getG2CompTyp() { return m_nG2CompTyp; };
	inline void setG2CompTyp(int G2CompTyp) { assert((-1<=G2CompTyp)&&(G2CompTyp<=2)); m_nG2CompTyp=G2CompTyp; };
	inline int getG2InitCompCat() { return m_nG2InitCompCat; };
	inline void setG2InitCompCat(int G2InitCompCat) { assert((-1<=G2InitCompCat)&&(G2InitCompCat<=1)); m_nG2InitCompCat=G2InitCompCat; };
	inline int getG2order1() { return m_nG2order1; };
	inline void setG2order1(int G2order1) { assert((0<=G2order1)&&(G2order1<=2)); m_nG2order1=G2order1; };
	inline int getG2order2() { return m_nG2order2; };
	inline void setG2order2(int G2order2) { assert((0<=G2order2)&&(G2order2<=6)); m_nG2order2=G2order2; };
	inline int getG2SV1() { return m_nG2SV1; };
	inline void setG2SV1(int G2SV1) { assert((G2SV1==0)||(G2SV1==1)); m_nG2SV1=G2SV1; };
	inline int getG2VS1() { return m_nG2VS1; };
	inline void setG2VS1(int G2VS1) { assert((G2VS1==0)||(G2VS1==1)); m_nG2VS1=G2VS1; };
	inline int getG2SV() { return m_nG2SV; };
	inline void setG2SV(int G2SV) { assert((G2SV==0)||(G2SV==1)); m_nG2SV=G2SV; };
	inline int getG2VS() { return m_nG2VS; };
	inline void setG2VS(int G2VS) { assert((G2VS==0)||(G2VS==1)); m_nG2VS=G2VS; };
	inline int getG2VO() { return m_nG2VO; };
	inline void setG2VO(int G2VO) { assert((G2VO==0)||(G2VO==1)); m_nG2VO=G2VO; };
	inline int getG2OV() { return m_nG2OV; };
	inline void setG2OV(int G2OV) { assert((G2OV==0)||(G2OV==1)); m_nG2OV=G2OV; };
	inline int getG2SO() { return m_nG2SO; };
	inline void setG2SO(int G2SO) { assert((G2SO==0)||(G2SO==1)); m_nG2SO=G2SO; };
	inline int getG2OS() { return m_nG2OS; };
	inline void setG2OS(int G2OS) { assert((G2OS==0)||(G2OS==1)); m_nG2OS=G2OS; };
	inline double getG2LexNhomrate() { return m_dG2LexNhomrate; };
	inline void setG2LexNhomrate(double G2LexNhomrate) { assert((FLOAT_SM_EQ(0.0, G2LexNhomrate))&&(FLOAT_SM_EQ(G2LexNhomrate, 1.0))); m_dG2LexNhomrate=G2LexNhomrate; };
	inline double getG2LexVhomrate() { return m_dG2LexVhomrate; };
	inline void setG2LexVhomrate(double G2LexVhomrate) { assert((FLOAT_SM_EQ(0.0, G2LexVhomrate))&&(FLOAT_SM_EQ(G2LexVhomrate, 1.0))); m_dG2LexVhomrate=G2LexVhomrate; };
	inline double getG2LexNVhomrate() { return m_dG2LexNVhomrate; };
	inline void setG2LexNVhomrate(double G2LexNVhomrate) { assert((FLOAT_SM_EQ(0.0, G2LexNVhomrate))&&(FLOAT_SM_EQ(G2LexNVhomrate, 1.0))); m_dG2LexNVhomrate=G2LexNVhomrate; };
	inline double getLexSim() { return m_dLexSim; };
	inline void setLexSim(double lexsim) { assert((FLOAT_SM_EQ(0.0, lexsim))&&(FLOAT_SM_EQ(lexsim, 1.0))); m_dLexSim=lexsim; };
	inline int getHorObliMix() { return m_nHorObliMix; };
	inline void setHorObliMix(int HorObliMix) { assert((HorObliMix==-1)||(HorObliMix==0)||(HorObliMix==1)||(HorObliMix==2)); m_nHorObliMix=HorObliMix; };
	inline int getMixHorVer() { return m_nMixHorVer; };
	inline void setMixHorVer(int mixHorVer) { assert((mixHorVer==-1)||(mixHorVer==0)||(mixHorVer==1)); m_nMixHorVer=mixHorVer; };
	inline int getNumAgentRep() { return m_nNumAgentRep; };
	inline void setNumAgentRep(int numAgentRep) { assert((0<=numAgentRep)&&(numAgentRep<=getNumAgent())); m_nNumAgentRep=numAgentRep; }
	inline int getCalTransMethod() { return m_nCalTransMethod; };
	inline void setCalTransMethod(int CalTransMethod) { assert((-1<=CalTransMethod)&&(CalTransMethod<=2)); m_nCalTransMethod=CalTransMethod; };
	inline double getAdultChildRatio() { return m_dAdultChildRatio; };
	inline void setAdultChildRatio(double adultchildRatio) { assert((FLOAT_SM_EQ(0.0, adultchildRatio))&&(FLOAT_SM_EQ(adultchildRatio, 1.0))); m_dAdultChildRatio=adultchildRatio; };
	inline double getChildChildRatio() { return m_dChildChildRatio; };
	inline void setChildChildRatio(double childchildRatio) { assert((FLOAT_SM_EQ(0.0, childchildRatio))&&(FLOAT_SM_EQ(childchildRatio, 1.0))); m_dChildChildRatio=childchildRatio; };
	inline double getChildAdultRatio() { return m_dChildAdultRatio; };
	inline void setChildAdultRatio(double childadultRatio) { assert((FLOAT_SM_EQ(0.0, childadultRatio))&&(FLOAT_SM_EQ(childadultRatio, 1.0))); m_dChildAdultRatio=childadultRatio; };
	inline double getVerProb() { return m_dVerProb; };
	inline void setVerProb(double verProb) { assert((FLOAT_SM_EQ(0.0, verProb))&&(FLOAT_SM_EQ(verProb, 1.0))); m_dVerProb=verProb; };
	inline double getPCRatio() { return m_dPCRatio; };
	inline void setPCRatio(double PCRatio) { assert((FLOAT_SM_EQ(0.0, PCRatio))&&(FLOAT_SM_EQ(PCRatio, 1.0))); m_dPCRatio=PCRatio; };
	inline double getACRatio() { return m_dACRatio; };
	inline void setACRatio(double ACRatio) { assert((FLOAT_SM_EQ(0.0, ACRatio))&&(FLOAT_SM_EQ(ACRatio, 1.0))); m_dACRatio=ACRatio; };
	inline double getCCRatio() { return m_dCCRatio; };
	inline void setCCRatio(double CCRatio) { assert((FLOAT_SM_EQ(0.0, CCRatio))&&(FLOAT_SM_EQ(CCRatio, 1.0))); m_dCCRatio=CCRatio; };
	inline double getCARatio() { return m_dCARatio; };
	inline void setCARatio(double CARatio) { assert((FLOAT_SM_EQ(0.0, CARatio))&&(FLOAT_SM_EQ(CARatio, 1.0))); m_dCARatio=CARatio; };
	inline double getGrandCRatio() { return m_dGrandCRatio; };
	inline void setGrandCRatio(double GrandCRatio) { assert((FLOAT_SM_EQ(0.0, GrandCRatio))&&(FLOAT_SM_EQ(GrandCRatio, 1.0))); m_dGrandCRatio=GrandCRatio; };
	inline double getParentCRatio() { return m_dParentCRatio; };
	inline void setParentCRatio(double ParentCRatio) { assert((FLOAT_SM_EQ(0.0, ParentCRatio))&&(FLOAT_SM_EQ(ParentCRatio, 1.0))); m_dParentCRatio=ParentCRatio; };
	inline double getChildCRatio() { return m_dChildCRatio; };
	inline void setChildCRatio(double ChildCRatio) { assert((FLOAT_SM_EQ(0.0, ChildCRatio))&&(FLOAT_SM_EQ(ChildCRatio, 1.0))); m_dChildCRatio=ChildCRatio; };
	inline int getGrandCType() { return m_nGrandCType; };
	inline void setGrandCType(int GrandCType) { assert((-1<=GrandCType)&&(GrandCType<=1)); m_nGrandCType=GrandCType; };
	inline int getParentCType() { return m_nParentCType; };
	inline void setParentCType(int ParentCType) { assert((-1<=ParentCType)&&(ParentCType<=1)); m_nParentCType=ParentCType; };
	inline int getVerTranRandCrt() { return m_nVerTranRandCrt; };
	inline void setVerTranRandCrt(int vertranrandcrt) { assert((-1<=vertranrandcrt)&&(vertranrandcrt<=1)); m_nVerTranRandCrt=vertranrandcrt; };
	inline int getVerTranWrongCue() { return m_nVerTranWrongCue; };
	inline void setVerTranWrongCue(int vertranwrongcue) { assert((-1<=vertranwrongcue)&&(vertranwrongcue<=1)); m_nVerTranWrongCue=vertranwrongcue; };
	inline int getDifAdultChild() { return m_nDifAdultChild; };
	inline void setDifAdultChild(int difadultchild) { assert((-1<=difadultchild)&&(difadultchild<=1)); m_nDifAdultChild=difadultchild; };
	inline double getDifRatio() { return m_dDifRatio; };
	inline void setDifRatio(double difratio) { assert((FLOAT_SM_EQ(0.0, difratio))&&(FLOAT_SM_EQ(difratio, 1.0))); m_dDifRatio=difratio; };
	inline int getSpUpd() { return m_nSpUpd; };
	inline void setSpUpd(int SpUpd) { assert((SpUpd==-1)||(SpUpd==0)||(SpUpd==1)); m_nSpUpd=SpUpd; };
	inline double getSpUpdProb() { return m_dSpUpdProb; };
	inline void setSpUpdProb(double SpUpdProb) { assert((FLOAT_SM_EQ(0.0, SpUpdProb))&&(FLOAT_SM_EQ(SpUpdProb, 1.0))); m_dSpUpdProb=SpUpdProb; };
	inline int getNumGen() { return m_nNumGen; };
	inline void setNumGen(int numGen) { assert(numGen>=0); m_nNumGen=numGen; };
	inline int getNumLearn() { return m_nNumLearn; };
	inline void setNumLearn(int numLearn) { assert(numLearn>=0); m_nNumLearn=numLearn; };
	inline int getHumanChimp() { return m_nHumanChimp; };
	inline void setHumanChimp(int humanchimp) { assert((-1<=humanchimp)&&(humanchimp<=5)); m_nHumanChimp=humanchimp; };
	inline double getA1() { return m_dA1; };
	inline void setA1(double A1) { assert(FLOAT_BG_EQ(A1, 0.0)); m_dA1=A1; };
	inline double getK1() { return m_dK1; };
	inline void setK1(double K1) { assert(FLOAT_SM_EQ(K1, 0.0)); m_dK1=K1; };
	inline double getA2() { return m_dA2; };
	inline void setA2(double A2) { assert(FLOAT_BG_EQ(A2, 0.0)); m_dA2=A2; };
	inline double getK2() { return m_dK2; };
	inline void setK2(double K2) { assert(FLOAT_SM_EQ(K2, 0.0)); m_dK2=K2; }; 
	inline double getScale() { return m_dScale; };
	inline void setScale(double scale) { assert(FLOAT_BG_EQ(scale, 0.0)); m_dScale=scale; };
	inline double getPopRat() { return m_dPopRat; };
	inline void setPopRat(double poprat) { assert((FLOAT_SM_EQ(0.0, poprat))&&(FLOAT_SM_EQ(poprat, 1.0))); m_dPopRat=poprat; };
	inline double getIntraRat() { return m_dIntraRat; };
	inline void setIntraRat(double intrarat) { assert((FLOAT_SM_EQ(-1.0, intrarat))&&(FLOAT_SM_EQ(intrarat, 1.0))); m_dIntraRat=intrarat; };
	inline double getInterRat() { return m_dInterRat; };
	inline void setInterRat(double interrat) { assert((FLOAT_SM_EQ(0.0, interrat))&&(FLOAT_SM_EQ(interrat, 1.0))); m_dInterRat=interrat; };
	inline int getWorldX() { return m_nWorldX; };
	inline void setWorldX(int worldX) { assert(worldX>=0); m_nWorldX=worldX; };
	inline int getWorldY() { return m_nWorldY; };
	inline void setWorldY(int worldY) { assert(worldY>=0); m_nWorldY=worldY; };
	inline int getBlockDist() { return m_nBlockDist; };
	inline void setBlockDist(int blockDist) { assert(blockDist>=0); m_nBlockDist=blockDist; };
	inline double getSucRat() { return m_dSucRat; };
	inline void setSucRat(double sucrat) { assert((FLOAT_SM_EQ(0.0, sucrat))&&(FLOAT_SM_EQ(sucrat, 1.0))); m_dSucRat=sucrat; };
	inline int getSucCri() { return m_nSucCri; };
	inline void setSucCri(int succri) { assert((succri==-1)||(succri==0)||(succri==1)); m_nSucCri=succri; };
	inline int getMoveStep() { return m_nMoveStep; };
	inline void setMoveStep(int movestep) { assert(movestep>=0); m_nMoveStep=movestep; };
	inline int get1toMCom() { return m_n1toMCom; };
	inline void set1toMCom(int flag1toMCom) { assert((flag1toMCom==-1)||(flag1toMCom==0)||(flag1toMCom==1)); m_n1toMCom=flag1toMCom; };
	inline int getSelfGrow() { return m_nSelfGrow; };
	inline void setSelfGrow(int selfgrow) { assert((selfgrow==-1)||(selfgrow==0)||(selfgrow==1)||(selfgrow==2)); m_nSelfGrow=selfgrow; };
	inline int getGATimeScale() { return m_nGATimeScale; };
	inline void setGATimeScale(int GATimeScale) { assert(GATimeScale>=0); m_nGATimeScale=GATimeScale; };
	inline int getNumSp() { return m_nNumSp; };
	inline void setNumSp(int numSp) { assert(numSp>=0); m_nNumSp=numSp; }; 
	inline int getCulSelType() { return m_nCulSelType; };
	inline void setCulSelType(int culselType) { assert((culselType==-1)||(culselType==0)||(culselType==1)); m_nCulSelType=culselType; };
	inline int getGeneSelType() { return m_nGeneSelType; };
	inline void setGeneSelType(int geneselType) { assert((geneselType==-1)|(geneselType==0)||(geneselType==1)); m_nGeneSelType=geneselType; };
	inline double getLearnAbiLow() { return m_dLearnAbiLow; };
	inline void setLearnAbiLow(double LearnAbiLow) { assert((FLOAT_SM_EQ(0.0, LearnAbiLow))&&(FLOAT_SM_EQ(LearnAbiLow, 1.0))); m_dLearnAbiLow=LearnAbiLow; };
	inline double getLearnAbiUp() { return m_dLearnAbiUp; };
	inline void setLearnAbiUp(double LearnAbiUp) { assert((FLOAT_SM_EQ(0.0, LearnAbiUp))&&(FLOAT_SM_EQ(LearnAbiUp, 1.0))); m_dLearnAbiUp=LearnAbiUp; };
	inline double getMutRate() { return m_dMutRate; };
	inline void setMutRate(double MutRate) { assert((FLOAT_SM_EQ(0.0, MutRate))&&(FLOAT_SM_EQ(MutRate, 1.0))); m_dMutRate=MutRate; };
	inline double getMutStep() { return m_dMutStep; };
	inline void setMutStep(double MutStep) { assert((FLOAT_SM_EQ(0.0, MutStep))&&(FLOAT_SM_EQ(MutStep, 1.0))); m_dMutStep=MutStep; };
	inline int getMemMutStep() { return m_nMemMutStep; };
	inline void setMemMutStep(int MemMutStep) { assert(MemMutStep>=0); m_nMemMutStep=MemMutStep; };
	inline int getMemMutType() { return m_nMemMutType; };
	inline void setMemMutType(int MemMutType) { assert((-1<=MemMutType)&&(MemMutType<=7)); m_nMemMutType=MemMutType; };
	inline int getNumCom() { return m_nNumCom; };
	inline void setNumCom(int numcom) { assert(numcom>=0); m_nNumCom=numcom; };
	inline int getNumInfoChange() { return m_nNumInfoChange; };
	inline void setNumInfoChange(int numinfochange) { assert(numinfochange>=0); m_nNumInfoChange=numinfochange; };
	inline int getCalAmbiguity() { return m_nCalAmbiguity; };
	inline void setCalAmbiguity(int CalAmbiguity) { assert((CalAmbiguity==-1)||(CalAmbiguity==0)||(CalAmbiguity==1)); m_nCalAmbiguity=CalAmbiguity; };
	inline int getRecMem() { return m_nRecMem; };
	inline void setRecMem(int RecMem) { assert((RecMem==-1)||(RecMem==0)||(RecMem==1)); m_nRecMem=RecMem; };
	inline int getShowComInfo() { return m_nShowComInfo; };
	inline void setShowComInfo(int showcominfo) { assert((showcominfo==-1)||(showcominfo==0)||(showcominfo==1)); m_nShowComInfo=showcominfo; };
	inline int getIndURCalMethod() { return m_nIndURCalMethod; };
	inline void setIndURCalMethod(int IndURCalMethod) { assert((IndURCalMethod==-1)||(IndURCalMethod==0)||(IndURCalMethod==1)); m_nIndURCalMethod=IndURCalMethod; }; 
	inline int getRecIndInfo() { return m_nRecIndInfo; };
	inline void setRecIndInfo(int RecIndInfo) { assert((RecIndInfo==-1)||(RecIndInfo==0)||(RecIndInfo==1)); m_nRecIndInfo=RecIndInfo; };
	inline int getRecURiniser() { return m_nRecURiniser; };
	inline void setRecURiniser(int RecURiniser) { assert((RecURiniser==-1)||(RecURiniser==0)||(RecURiniser==1)); m_nRecURiniser=RecURiniser; };
	// other operations;
	void ChkConsistAll();	// check all agents whether all lexical rules, categories and syntactic rules are linked together in m_pLTMem; 
	void ChkConsist(int type, CAgent *Ag);	// check one specific agent whether all lexical rules, categories and syntactic rules are linked together in m_pLTMem; 
	void calUseOrder(int type, int meanIndex, int Agindex, CMeanUtter *meanutter, double **syn, int size11, int size12, double **Localsyn, int size21, int size22, double **OrdPro_Per, int size31, int size32, double **eachAgOrdPro_Per, int size41, int size42);	// test which order agent used to produce/comprehend; 0(SV), 1(VS), 2(SVO), 3(SOV), 4(OSV), 5(VSO), 6(VOS), 7(OVS);
	double calAgUR(int agind);	// calculate inidividual agent's UR;
	void testURini(int NormOrTest, int lowBound, int upBound, double *URini);	// test URini (m_ppAgent <-> m_ppAgent1);
	void testURser(int NormOrTest, int lowBound, int upBound, double *URser);	// test URser (m_ppAgent <-> m_ppAgentN);
	void testUR_Exp_Amb(int NormOrTest, int lowBound, int upBound, double *eachUR, int size, double *UR, double *REall, double *Amb_a, double *Amb_b, double *Amb_c, double **syn, int size11, int size12, double **Localsyn, int size21, int size22, double **OrdPro, double **OrdPer, int size31, int size32, double **eachAgOrdPro, double **eachAgOrdPer, int size41, int size42);	// test eachUR, UR, REall, synUR, synExp, OrdPro, OrdPer, eachAgOrdPro, eachAgOrdPer;
	void testCrossUR_Exp_Amb(int NormOrTest, int lowBound1, int upBound1, int lowBound2, int upBound2, double *eachUR, int size, double *UR, double *REall, double *Amb_a, double *Amb_b, double *Amb_c, double **syn, int size11, int size12, double **Localsyn, int size21, int size22, double **OrdPro, double **OrdPer, int size31, int size32, double **eachAgOrdPro, double **eachAgOrdPer, int size41, int size42);	// test cross group eachUR, UR, REall, synUR, synExp, OrdPro, OrdPer, eachAgOrdPro, eachAgOrdPer;
	void testDisp(int NormOrTest, int lowBound, int upBound, double *displacement, int size, double *avgDisp);	// test displacement;
	void testCrossDisp(int NormOrTest, int lowBound1, int upBound1, int lowBound2, int upBound2, double *displacement, int size, double *avgDisp);	// test cross group displacement;
	void testHolistCompExp(int lowBound, int upBound, double *REholist, double *REcomp);	// test holistic rule and compositional rule's expressivity;
	void testAvgLexCatSyn(int lowBound, int upBound, double *AvgHolistLex, double *AvgCompLex, double *AvgCat, double *AvgSyn, double *AvgLocSyn, double *AvgSnum, double *AvgVnum, double *AvgOnum, double *AvgSsize, double *AvgVsize, double *AvgOsize, double **catSize);	// test average lexical rules, categories and syntactic rules, the numbers, average and biggest sizes of Subject, Verb and Object categories;;
	void updComLex(CLexRule *lex, CLexRule **&comLex, double avgstr, double *&comLexAvgStr, int *numcomLex);	// update lex into comLex;
	void testComLex(int lowBound, int upBound, CLexRule **&comLex, double *&comLexAvgStr, int *numcomLex, int *numcomHolist, int *numcomComp);	// test common lexical rules;
	void testHomo(CLexRule **comLex, int numcomLex, int numcomHolist, int numcomComp, int *numHomoN, int *numHomoV, int *numHomoNV);	// test numHomoN, numHomoV, numHomoNV based on comLex;
	bool chkDist(CAgent *Ag1, CAgent *Ag2);	// check whether 2 agents' distance is within the block distance;
	double calDist(CAgent *Ag1, CAgent *Ag2);	// calculate the distance of two agents;
	void testNeighborUR_Size(int NormOrTest, double *AdjDist, int sizeAdjDist, double *neighborUR, int *neighborSize, CAgent ***Neighbor, int **NeighborInd, int size);	// test neighborUR and neighborSize;
	void testNeighborComLex(int *neighborSize, CAgent ***Neighbor, int **NeighborInd, CLexRule ***neighborComLex, double **NeighborComLexAvgStr, int *NoneighborComLex, int size);	// test neighbor's comLex;
	void testChildUR(int NormOrTest, int *ChildAgInd, double *ChildUR);	// testing children's UR;
	void TestPara(int gen, int com, FILE **f, char **fileNam, int *ChildAgInd, CNet *adjMatrix);	// testing parameters;
	void HorInfoChange(CAgent *SpAgent, CAgent *LiAgent, int *NumPosFeedback);	// one information exchange in a horizontal transmission;
	void VerInfoChange(CAgent *SpAgent, CAgent *newAgent, int *NumPosFeedback);	// one information exchange in a vertical transmission;
	void SelfTalk(CAgent *SpAgent, CAgent *selfcopy, int *NumPosFeedback);	// self-talk;
 	void OneToManyInfoChange(CAgent *SpAgent, CAgent **Neighbor, int numNeighbor, int *NumPosFeedback);	// one infochange in one speaker, many listeners communication;
	void HorCom(CAgent *SpAgent, CAgent *LiAgent, int *NumPosFeedback);	// horizontal communication;
	void VerCom(int type, CAgent *SpAgent, CAgent *LiAgent, int Sp_LiInd, int *NumPosFeedback);	// vertical communication; type=0, adult-child; 1, child->adult;
	void OneToManyCom(CAgent *SpAgent, CAgent **Neighbor, int numNeighbor, int *NumPosFeedback);	// one speaker, many listeners communication;
	void AdjBuffer(CAgent *SpAgent, CAgent *selfcopy);	// empty SpAgent->m_pBufer;
	void AdjLTMem(CAgent *selfcopy, CAgent *SpAgent);	// adjust selfcopy and SpAgent->m_pLTMem;
	void CrtSelfCopy(CAgent *SpAgent, CAgent *&selfcopy);	// create a selfcopy of SpAgent;
	void CrtnewAgent(CAgent *RepAgent, CAgent *&newAgent);	// create newAgent from RepAgent;
	void EmpSelfCopy(CAgent *&selfcopy);	// empty selfcopy;
	void RepnewAgent(CAgent *OldAgent, CAgent *&newAgent);	// replace OldAgent with newAgent;
	void InitNewAgent(int *&repAgentInd, CAgent **&newAgent);	// create repAgentInd and newAgent;
	void ReplaceAgent(int *repAgentInd, CAgent **newAgent);	// replace newAgent; 
	void updNeighbor(CAgent *Ag, int AgInd, CAgent **&Neighbor, int *&NeighborInd, int *numNeighbor);	// insert Ag and AgInd into Neighbor and NeighborInd;
	void CrtNeighborAdult(CAgent *SpAgent, CAgent **&Neighbor, int *&NeighborInd, int *numNeighbor);	// build up SpAgent's adult neighbors;
	void CrtNeighborChild(CAgent *SpAgent, CAgent **newAgent, int *repAgentInd, int numAgentRep, CAgent **&Neighbor, int *&NeighborInd, int *numNeighbor);	// build up SpAgent's child neighbor;
	void MoveAgent(CAgent *Ag, CAgent **Neighbor, int numNeighbor, int SucCom);	// move Ag; SucCom=1, move Ag and keep constrains between Ag and Neighbors; SucCom=0, random move Ag;
	void MoveNeighbor(CAgent *MovAg, CAgent *OriAg);	// move MovAg and try keeping the distance between MovAg and OriAg within the block distance;
	void RecNetTyp(FILE *f, CNet *adjMatrix);	// record network type;
	void RecComMode(FILE *f, char *fileName, CNet *adjMatrix);	// record ComMode, DecFlag, SelfTalkFlag;
	void Forget(int TimScale, int NoCom_Gen, CAgent **AgSet, int NoAg);	// every TimScale, let all agents in AgSet to forget;
	void Adult_RandCom(int numcom);	// Adult-Adult communication in random com mode;
	void Child_RandCom(int cond, int numlearn, int *repAgentInd, CAgent **newAgent, int *choseIndex, CAgent **grandAgent);	// Adult-Child, Child-Child, Child-Adult communication in random com mode; cond=0, no grandparent-child talks; 1, having grandparent-child talks;
	void adjAdultChild();	// adjust children to adults;
	void RandCom(FILE **f, char **fileNam);	// Random Com;
	void PairCom(FILE **f, char **fileNam);	// Pair com mode: pairs of agents communicate in each com round;
	void TeachLearn(FILE **f, char **fileNam);	// teacher-learner mode: teacher learner communicate in each com round;
	void recPoprate(int cond, double *Pop, int PopSize, FILE *f, char *fileNam);	// record popular rates of each individual to a file; cond=1, store values before normalization; cond=2, store values after normalization;
	void InitPopularity(int type, double *PopularitySP, double *PopularityLI, int PopSize, FILE **f, char **fileNam);	// initialize Popularity;
	int ChoAgPopularity(double *Popularity, int PopSize);	// choose agent according to Popularity;
	void PopCom(FILE **f, char **fileNam);	// popular agent;void Adult_World2D(int numcom);	// Adult-Adult communication in world2d mode;
	void Adult_World2D(int numcom);	// Adult-Adult communication in world2d mode;
	void Child_World2D(int numlearn, int *repAgentInd, CAgent **newAgent);	// Adult-Child, Child-Child, Child-Adult communication in world2d mode;
	void World2D(FILE **f, char **fileNam);	// 2D world com;
	void Adult_SolCom(int numcom, CNet *adjMatrix);	// Adult-Adult communication in solcom mode (under different social structures);
	void Child_SolCom(int numlearn, int *repAgentInd, CAgent **newAgent, CNet *adjMatrix);	// Adult-Child, Child-Child, Child-Adult communication in solcom mode (under different social structures);
	void setLocalView(int speaker, double **&LocalView, CNet *adjMatrix);	// set up LocalView for speaker;
	void Adult_SolGrowCom(int numcom, CNet *adjMatrix);	// Adult-Adult communication in solcom mode (under self-grow social structures);
	void Child_SolGrowCom(int numlearn, int *repAgentInd, CAgent **newAgent, CNet *adjMatrix);	// Adult-Child, Child-Child, Child-Adult communication in solcom mode (under self-grow social structures);
	void SolCom(FILE **f, char **fileNam);	// language and social structure emergence;
	void SelParRepSp(int type, int size, double **sort, double **fitness, int *chosenIndex);	// type=0, random select (different); 1, random select (identical is possible); 2, chose the best (identical is possible); 3, chose the worst (different);
	void GeneCulSel(int *repAgentInd, int *IndexParent, int *IndexSp, double **genome, int size1, int size2);	// gene-cultural selection of parents; getGeneSelType()=0, randomly select agents as parents; 1, select best agents; getCulSelType()=0, randomly select agents as speakers; 1, select best agents;
	void MutRCMem(int cond, double *newRC, int *newMem);	// mutation of RC or Mem; cond=1, mutation of RC; 2, mutation of memory capacity;
	void GACulopt(int com_gen, CAgent **&newAgent, int *repAgentInd, int *IndexParent, int *IndexSp);	// using genetic selection and cultural selection to adjust indiviudals' learning abilities;
	void GACulrandCom(FILE **f, char **fileNam);	// language and individual learning abilities can coevolve;
	void MemLangopt(int com_gen, CAgent **&newAgent, int *repAgentInd, int *IndexParent, int *IndexSp);	// using genetic selection and cultural selection to adjust indiviudals' memory capacity;
	void MemLangrandCom(FILE **f, char **fileNam);	// language and memory capacity can coevolve;
	void JALTMLangopt(int com_gen, CAgent **&newAgent, int *repAgentInd, int *IndexParent, int *IndexSp);	// using genetic selection and cultural selection to adjust indiviudals' joint attention and LTM capacity;
	void JALTMrandCom(FILE **f, char **fileNam);	// Lang-JA&LTM coevolution;
};
